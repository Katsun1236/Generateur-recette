<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Générateur de Recettes Minecraft</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <!-- On charge les fichiers de données avant le script principal -->
    <script src="item_list/item_data.js" defer></script>
    <script src="recipes_config.js" defer></script>
    <style>
        :root {
            --background-color: #585858;
            --container-bg: #C6C6C6;
            --slot-bg: #8B8B8B;
            --border-dark: #3c3c3c;
            --border-light: #a0a0a0;
            --font-color: #FFFFFF;
            --shadow-color: #3c3c3c;
            --pixel-font: 'Press Start 2P', cursive;
            --green-button: #5a9d43;
            --blue-button: #4a75d1;
        }
        body {
            font-family: var(--pixel-font);
            background-color: var(--background-color);
            background-image: url('https://www.transparenttextures.com/patterns/rocky-wall.png');
            color: var(--font-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            image-rendering: pixelated;
        }
        h1, h2 {
            color: var(--font-color);
            text-shadow: 3px 3px var(--shadow-color);
        }
        .main-container {
            display: grid;
            grid-template-columns: 240px 1fr;
            gap: 20px;
            width: 100%;
            max-width: 950px;
        }
        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #search-bar {
            font-family: var(--pixel-font);
            font-size: 12px;
            padding: 8px;
            border: 3px inset #525252;
            background-color: var(--slot-bg);
            color: #FFFFFF;
            text-shadow: 1px 1px #3c3c3c;
            text-align: center;
            width: 100%;
            box-sizing: border-box;
        }
        #search-bar::placeholder { color: #dddddd; }
        #item-list {
            background-color: var(--container-bg);
            border: 4px solid var(--border-dark);
            border-right-color: var(--border-light);
            border-bottom-color: var(--border-light);
            padding: 10px;
            height: 550px;
            overflow-y: auto;
            flex-grow: 1;
        }
        #item-list .item {
            width: 48px;
            height: 48px;
            padding: 4px;
            margin: 2px;
            box-sizing: border-box;
            border: 2px solid var(--border-dark);
            background-color: var(--slot-bg);
            cursor: grab;
            display: inline-block;
        }
        .item:active { cursor: grabbing; }
        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .mode-selector { text-align: center; }
        .mode-btn, .action-btn {
            background-color: var(--slot-bg);
            font-family: var(--pixel-font);
            font-size: 14px;
            color: var(--font-color);
            border: 4px solid var(--border-dark);
            padding: 10px 15px;
            cursor: pointer;
            text-shadow: 2px 2px var(--shadow-color);
        }
        .mode-btn.active {
            background-color: var(--green-button);
            border-color: var(--border-light) var(--border-dark) var(--border-dark) var(--border-light);
        }
        .action-btn { background-color: var(--blue-button); }
        .interface-container {
            background-color: var(--container-bg);
            border: 4px solid var(--border-dark);
            border-right-color: var(--border-light);
            border-bottom-color: var(--border-light);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        #furnace-interface { display: none; }
        #crafting-type-selector { display: flex; gap: 10px; }
        .crafting-area {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        #crafting-grid {
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(3, 60px);
            gap: 4px;
            background-color: var(--border-dark);
            border: 4px solid var(--border-light);
            border-right-color: var(--border-dark);
            border-bottom-color: var(--border-dark);
            padding: 4px;
        }
        .grid-slot {
            width: 60px;
            height: 60px;
            background-color: var(--slot-bg);
            border: 2px inset #525252;
            box-sizing: border-box;
            position: relative;
        }
        .grid-slot.drag-over { border: 2px solid var(--green-button); }
        .grid-slot[draggable="true"] { cursor: grab; }
        .grid-slot[draggable="true"]:active { cursor: grabbing; }
        .grid-slot img { width: 100%; height: 100%; object-fit: contain; pointer-events: none; }
        .arrow { font-size: 40px; text-shadow: 3px 3px var(--shadow-color); }
        .furnace-slots { display: flex; flex-direction: column; gap: 10px; align-items: center; }
        .flame-icon {
            width: 32px; height: 32px;
            margin-top: 14px;
            margin-bottom: 14px;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23ff9800'%3E%3Cpath d='M13.04 2.21C12.03 2.76 11.33 3.75 11.33 4.88c0 .54.19 1.05.5 1.48-.52 2.63-2.43 4.54-5.07 5.07C6.22 11.52 5.71 11.33 5.18 11.33c-1.13 0-2.12.7-2.67 1.71C2.21 13.56 2 14.28 2 15c0 2.21 1.79 4 4 4 .72 0 1.44-.21 2.05-.56 1.01.55 2 .84 3 .84s1.99-.29 3-.84c.61.35 1.33.56 2.05.56 2.21 0 4-1.79 4-4 0-.72-.21-1.44-.56-2.05-.55-1.01-.84-2-1.39-3.04.63-.44 1.15-1.01 1.48-1.71.55-1.01.28-2.28-.73-2.79-1.01-.52-2.28-.24-2.79.77-.32.6-.45 1.28-.4 1.96-1.85-1.28-3.08-3.23-3.41-5.43.32-.23.54-.6.54-1.02 0-1.13-.7-2.12-1.71-2.67z'/%3E%3C/svg%3E") no-repeat center center;
        }
        .variant-indicator {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 15px;
            height: 15px;
            background-color: var(--blue-button);
            color: white;
            font-size: 10px;
            line-height: 15px;
            text-align: center;
            border-radius: 50%;
            border: 1px solid var(--border-dark);
            text-shadow: none;
            cursor: pointer;
            z-index: 2;
        }
        .controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
        }
        .control-group { display: flex; flex-direction: column; align-items: center; gap: 5px; }
        .control-group label { font-size: 12px; text-shadow: 2px 2px var(--shadow-color); }
        .control-group input {
            font-family: var(--pixel-font); font-size: 12px; padding: 8px;
            border: 3px inset #525252; background-color: var(--slot-bg);
            color: var(--font-color); text-align: center;
        }
        input[type=number] { width: 80px; }
        .main-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        #download-btn {
            background-color: var(--green-button);
            font-family: var(--pixel-font);
            color: white; font-size: 16px;
            border: 4px solid var(--border-dark);
            border-right-color: var(--border-light);
            border-bottom-color: var(--border-light);
            padding: 15px 25px; cursor: pointer;
            text-shadow: 2px 2px var(--shadow-color);
        }
        #download-btn:active { border-color: var(--border-light) var(--border-dark) var(--border-dark) var(--border-light); }
        #output-container { width: 100%; max-width: 950px; text-align: center; }
        #output-code {
            background-color: #2a2a2a; border: 4px solid var(--border-dark); padding: 15px;
            width: 100%; min-height: 200px; white-space: pre-wrap; word-break: break-all;
            color: #e0e0e0; text-align: left; font-size: 14px; box-sizing: border-box;
        }
        .modal {
            display: none; position: fixed; z-index: 10;
            left: 0; top: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.6);
            align-items: center; justify-content: center;
        }
        .modal-content {
            background-color: var(--container-bg); padding: 20px;
            border: 4px solid var(--border-dark);
            border-right-color: var(--border-light);
            border-bottom-color: var(--border-light);
            min-width: 300px; max-width: 500px;
        }
        .modal-header {
            display: flex; justify-content: space-between;
            align-items: center; margin-bottom: 15px;
        }
        .modal-header h2 { margin: 0; font-size: 16px; }
        .close-btn { font-family: var(--pixel-font); font-size: 20px; cursor: pointer; }
        .modal-body {
            display: flex; flex-wrap: wrap; gap: 10px;
            background: var(--slot-bg); padding: 10px;
            border: 2px inset #525252;
        }
        .modal-item { display: flex; align-items: center; gap: 8px; font-size: 12px; }
        .modal-item img { width: 32px; height: 32px; }
        #list-btn {
            display: inline-block;
            margin-bottom: 20px;
            background-color: var(--green-button);
            padding: 15px 25px;
            font-size: 16px;
            text-align: center;
            border: 4px solid var(--border-dark);
            border-right-color: var(--border-light);
            border-bottom-color: var(--border-light);
            text-shadow: 2px 2px var(--shadow-color);
        }
        #list-btn:active {
            border-color: var(--border-light) var(--border-dark) var(--border-dark) var(--border-light);
        }
        #furnace-type-selector {
            display: none;
            gap: 10px;
            margin-top: -10px;
            padding-bottom: 10px;
        }

        /* Mobile Friendliness */
        @media (max-width: 800px) {
            body {
                padding: 10px;
            }
            .main-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            .left-panel {
                order: 2;
            }
            .right-panel {
                order: 1;
            }
            #item-list {
                height: 180px;
                display: flex;
                flex-wrap: wrap;
                align-content: flex-start;
            }
             h1 {
                font-size: 1.5em;
                text-align: center;
            }
            .grid-slot {
                width: 50px;
                height: 50px;
            }
            #crafting-grid {
                grid-template-columns: repeat(3, 50px);
                grid-template-rows: repeat(3, 50px);
            }
            .arrow {
                font-size: 30px;
            }
            .mode-btn, .action-btn, #download-btn {
                font-size: 12px;
                padding: 8px 12px;
            }
            #output-container h2 {
                font-size: 1.2em;
            }
        }
    </style>
</head>
<body>

    <h1>Générateur de Recettes</h1>
    <a href="list.html" class="action-btn" id="list-btn">Voir la Liste des Items</a>

    <div class="main-container">
        <div class="left-panel">
            <input type="text" id="search-bar" placeholder="Rechercher un item...">
            <div id="item-list"></div>
        </div>

        <div class="right-panel">
            <div class="mode-selector">
                <button id="crafting-btn" class="mode-btn">Établi</button>
                <button id="furnace-btn" class="mode-btn">Four</button>
            </div>

            <div id="crafting-interface" class="interface-container">
                 <div id="crafting-type-selector">
                      <button id="shaped-btn" class="mode-btn active">Shaped</button>
                      <button id="shapeless-btn" class="mode-btn">Shapeless</button>
                 </div>
                 <div class="crafting-area">
                      <div id="crafting-grid">
                           <div class="grid-slot" data-index="0"></div><div class="grid-slot" data-index="1"></div><div class="grid-slot" data-index="2"></div>
                           <div class="grid-slot" data-index="3"></div><div class="grid-slot" data-index="4"></div><div class="grid-slot" data-index="5"></div>
                           <div class="grid-slot" data-index="6"></div><div class="grid-slot" data-index="7"></div><div class="grid-slot" data-index="8"></div>
                      </div>
                      <div class="arrow">→</div>
                      <div id="result-slot-crafting" class="grid-slot"></div>
                 </div>
                 <button id="clear-grid-btn" class="action-btn">Vider la Grille</button>
            </div>

            <div id="furnace-interface" class="interface-container">
                <div class="crafting-area">
                    <div class="furnace-slots">
                         <div id="input-slot-furnace" class="grid-slot"></div>
                         <div class="flame-icon"></div>
                    </div>
                    <div class="arrow">→</div>
                    <div id="result-slot-furnace" class="grid-slot"></div>
                </div>
            </div>
            
            <div id="furnace-type-selector">
                <button id="blast-furnace-btn" class="mode-btn">Haut Fourneau</button>
                <button id="smoker-btn" class="mode-btn">Fumoir</button>
            </div>
            
             <div class="controls">
                  <div class="control-group">
                       <label for="result-count">Quantité</label>
                       <input type="number" id="result-count" value="1" min="1" max="64">
                  </div>
                  <div class="control-group" id="experience-control" style="display: none;">
                       <label for="furnace-experience">Expérience</label>
                       <input type="number" id="furnace-experience" value="0.15" step="0.05" min="0">
                  </div>
             </div>

            <div class="main-actions">
                 <button id="download-btn">Télécharger le Fichier</button>
            </div>
        </div>
    </div>
    
    <div id="output-container">
        <h2>Aperçu du Code</h2>
        <pre id="output-code"></pre>
    </div>

    <div id="variant-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Items dans la case</h2>
                <span class="close-btn">&times;</span>
            </div>
            <div class="modal-body"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const itemListContainer = document.getElementById('item-list');
            const craftingBtn = document.getElementById('crafting-btn');
            const furnaceBtn = document.getElementById('furnace-btn');
            const shapedBtn = document.getElementById('shaped-btn');
            const shapelessBtn = document.getElementById('shapeless-btn');
            const craftingInterface = document.getElementById('crafting-interface');
            const furnaceInterface = document.getElementById('furnace-interface');
            const allSlots = document.querySelectorAll('.grid-slot');
            const downloadBtn = document.getElementById('download-btn');
            const clearGridBtn = document.getElementById('clear-grid-btn');
            const outputCode = document.getElementById('output-code');
            const resultCountInput = document.getElementById('result-count');
            const searchBar = document.getElementById('search-bar');
            const experienceControl = document.getElementById('experience-control');
            const experienceInput = document.getElementById('furnace-experience');
            const variantModal = document.getElementById('variant-modal');
            const modalBody = variantModal.querySelector('.modal-body');
            const closeModalBtn = variantModal.querySelector('.close-btn');

            const furnaceTypeSelector = document.getElementById('furnace-type-selector');
            const blastFurnaceBtn = document.getElementById('blast-furnace-btn');
            const smokerBtn = document.getElementById('smoker-btn');

            let currentMode = 'crafting';
            let currentCraftingType = 'shaped';
            let draggedSlotElement = null;
            let activeFurnaceTags = new Set();
            let items = new Map();

            // S'assure que ALL_ITEMS et CRAFTING_RECIPES sont bien chargés
            if (typeof ALL_ITEMS === 'undefined' || typeof CRAFTING_RECIPES === 'undefined') {
                console.error("Les listes d'items ou de recettes n'ont pas pu être chargées.");
                itemListContainer.innerHTML = `<p style="color: #3c3c3c; font-size: 10px; text-align: center;">Erreur: Fichiers de données non trouvés.</p>`;
                return; // Stoppe l'exécution
            }

            // Transformation du tableau d'objets en Map d'objets
            items = new Map(ALL_ITEMS.map(item => {
                 const filename = item.id.replace(':', '_');
                 return [item.id, { id: item.id, name: item.name, img: `items/${filename}.png` }];
            }));


            function renderItemList(filter = '') {
                itemListContainer.innerHTML = '';
                const sortedItems = new Map([...items.entries()].sort((a, b) => a[1].name.localeCompare(b[1].name)));
                sortedItems.forEach((item, id) => {
                    const searchString = `${item.name} ${id}`.toLowerCase();
                    if (searchString.includes(filter.toLowerCase())) {
                        const img = document.createElement('img');
                        img.src = item.img;
                        img.alt = item.name;
                        img.title = item.name; // Ajoute un tooltip avec le nom de l'item
                        img.className = 'item';
                        img.draggable = true;
                        img.setAttribute('data-item-id', id);
                        img.addEventListener('dragstart', (e) => {
                            e.dataTransfer.setData('source', 'list');
                            e.dataTransfer.setData('itemId', id);
                        });
                        img.addEventListener('dblclick', () => displayRecipe(id));
                        itemListContainer.appendChild(img);
                    }
                });
            }
            
            function displayRecipe(itemId) {
                const recipe = CRAFTING_RECIPES[itemId];
                if (!recipe) return;

                document.querySelectorAll('.grid-slot').forEach(clearSlot);

                if (recipe.type === 'furnace') {
                    switchMode('furnace');
                    const inputSlot = document.getElementById('input-slot-furnace');
                    const resultSlot = document.getElementById('result-slot-furnace');
                    const inputId = Array.isArray(recipe.input) ? recipe.input[0] : recipe.input;
                    handleItemDropFromList(inputSlot, inputId);
                    handleItemDropFromList(resultSlot, itemId);
                } else {
                    switchMode('crafting');
                    const resultSlot = document.getElementById('result-slot-crafting');
                    handleItemDropFromList(resultSlot, itemId);

                    if (recipe.type === 'shaped') {
                        switchCraftingType('shaped');
                        const pattern = recipe.pattern;
                        const ingredients = recipe.ingredients;
                        const gridSlots = document.querySelectorAll('#crafting-grid .grid-slot');
                        
                        const patternHeight = pattern.length;
                        const patternWidth = pattern[0].length;
                        const startRow = (patternHeight < 3 && pattern.every(r => r.length < 3)) ? 1 : 0;
                        const startCol = (patternWidth < 3 && pattern.every(r => r.length < 3)) ? 1 : 0;

                        pattern.forEach((row, rowIndex) => {
                            for (let colIndex = 0; colIndex < row.length; colIndex++) {
                                const key = row[colIndex];
                                if (key !== ' ') {
                                    const ingredientVariants = ingredients[key];
                                    if (ingredientVariants && ingredientVariants.length > 0) {
                                        const slotIndex = (rowIndex + startRow) * 3 + (colIndex + startCol);
                                        const targetSlot = gridSlots[slotIndex];
                                        if(targetSlot) {
                                           handleItemDropFromList(targetSlot, ingredientVariants[0]);
                                           targetSlot.dataset.variants = JSON.stringify(ingredientVariants);
                                           updateSlotVisuals(targetSlot);
                                        }
                                    }
                                }
                            }
                        });
                    } else if (recipe.type === 'shapeless') {
                        switchCraftingType('shapeless');
                        const gridSlots = document.querySelectorAll('#crafting-grid .grid-slot');
                        recipe.ingredients.forEach((ingredientId, index) => {
                            if (gridSlots[index]) {
                                handleItemDropFromList(gridSlots[index], ingredientId);
                            }
                        });
                    }
                }
            }

            renderItemList();
            searchBar.addEventListener('input', (e) => renderItemList(e.target.value));

            allSlots.forEach(slot => {
                slot.addEventListener('dragover', (e) => { e.preventDefault(); slot.classList.add('drag-over'); });
                slot.addEventListener('dragleave', () => { slot.classList.remove('drag-over'); });
                
                slot.addEventListener('dragstart', (e) => {
                    if (slot.querySelector('img')) {
                        draggedSlotElement = slot;
                        e.dataTransfer.setData('source', 'slot');
                        e.dataTransfer.setData('variants', slot.dataset.variants || '[]');
                    } else {
                        e.preventDefault();
                    }
                });

                slot.addEventListener('drop', (e) => {
                    e.preventDefault();
                    slot.classList.remove('drag-over');
                    const source = e.dataTransfer.getData('source');
                    if (source === 'list') {
                        const itemId = e.dataTransfer.getData('itemId');
                        handleItemDropFromList(slot, itemId);
                    } else if (source === 'slot' && draggedSlotElement) {
                        handleItemDropFromSlot(slot);
                    }
                });
                
                slot.addEventListener('dblclick', () => { clearSlot(slot); });
            });

            function handleItemDropFromList(targetSlot, itemId) {
                const itemData = items.get(itemId);
                if (!itemData) return;
                const existingImg = targetSlot.querySelector('img');
                let variants = targetSlot.dataset.variants ? JSON.parse(targetSlot.dataset.variants) : [];
                
                if (existingImg && currentCraftingType === 'shaped' && !variants.includes(itemId)) {
                    variants.push(itemId);
                } else {
                    targetSlot.innerHTML = '';
                    const img = document.createElement('img');
                    img.src = itemData.img;
                    img.setAttribute('data-item-id', itemId);
                    targetSlot.appendChild(img);
                    variants = [itemId];
                }
                targetSlot.dataset.variants = JSON.stringify(variants);
                targetSlot.draggable = true;
                updateSlotVisuals(targetSlot);
            }

            function handleItemDropFromSlot(targetSlot) {
                if (draggedSlotElement === targetSlot) return;
                const sourceVariants = draggedSlotElement.dataset.variants;
                const sourceHTML = draggedSlotElement.innerHTML;
                const targetVariants = targetSlot.dataset.variants;
                const targetHTML = targetSlot.innerHTML;

                if (targetHTML) { 
                    draggedSlotElement.innerHTML = targetHTML;
                    draggedSlotElement.dataset.variants = targetVariants;
                    draggedSlotElement.draggable = true;
                } else { 
                    clearSlot(draggedSlotElement);
                }
                targetSlot.innerHTML = sourceHTML;
                targetSlot.dataset.variants = sourceVariants;
                targetSlot.draggable = true;
                updateSlotVisuals(draggedSlotElement);
                updateSlotVisuals(targetSlot);
                draggedSlotElement = null;
            }
                
            function clearSlot(slot) {
                slot.innerHTML = '';
                delete slot.dataset.variants;
                slot.draggable = false;
                updateSlotVisuals(slot);
            }

            function updateSlotVisuals(slot) {
                let variants = slot.dataset.variants ? JSON.parse(slot.dataset.variants) : [];
                let indicator = slot.querySelector('.variant-indicator');
                if (variants.length > 1 && currentCraftingType === 'shaped') {
                    if (!indicator) {
                        indicator = document.createElement('div');
                        indicator.className = 'variant-indicator';
                        indicator.textContent = '+';
                        indicator.addEventListener('click', (e) => {
                           e.stopPropagation();
                           showVariantModal(variants);
                        });
                        slot.appendChild(indicator);
                    }
                    slot.title = variants.join('\n');
                } else {
                    if (indicator) slot.removeChild(indicator);
                    slot.title = '';
                }
            }

            clearGridBtn.addEventListener('click', () => {
                document.querySelectorAll('#crafting-interface .grid-slot').forEach(clearSlot);
            });

            function switchMode(mode) {
                currentMode = mode;
                document.getElementById('crafting-type-selector').style.display = (mode === 'crafting') ? 'flex' : 'none';
                craftingInterface.style.display = (mode === 'crafting') ? 'flex' : 'none';
                furnaceInterface.style.display = (mode === 'furnace') ? 'flex' : 'none';
                experienceControl.style.display = (mode === 'furnace') ? 'flex' : 'none';
                craftingBtn.classList.toggle('active', mode === 'crafting');
                furnaceBtn.classList.toggle('active', mode === 'furnace');
                
                furnaceTypeSelector.style.display = (mode === 'furnace') ? 'flex' : 'none';
            }

            function switchCraftingType(type) {
                currentCraftingType = type;
                shapedBtn.classList.toggle('active', type === 'shaped');
                shapelessBtn.classList.toggle('active', type === 'shapeless');
            }

            craftingBtn.addEventListener('click', () => switchMode('crafting'));
            furnaceBtn.addEventListener('click', () => switchMode('furnace'));
            shapedBtn.addEventListener('click', () => switchCraftingType('shaped'));
            shapelessBtn.addEventListener('click', () => switchCraftingType('shapeless'));
            switchMode('crafting');

            blastFurnaceBtn.addEventListener('click', () => {
                const tag = 'blast_furnace';
                blastFurnaceBtn.classList.toggle('active');
                if (activeFurnaceTags.has(tag)) {
                    activeFurnaceTags.delete(tag);
                } else {
                    activeFurnaceTags.add(tag);
                }
            });

            smokerBtn.addEventListener('click', () => {
                const tag = 'smoker';
                smokerBtn.classList.toggle('active');
                if (activeFurnaceTags.has(tag)) {
                    activeFurnaceTags.delete(tag);
                } else {
                    activeFurnaceTags.add(tag);
                }
            });

            downloadBtn.addEventListener('click', () => {
                const { recipe, fileName } = currentMode === 'crafting' ? generateCraftingRecipe() : generateFurnaceRecipe();
                if (recipe && fileName) {
                    const jsonString = JSON.stringify(recipe, null, 2);
                    outputCode.textContent = jsonString;
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            });
                
            function generateCraftingRecipe() {
                const resultItem = document.querySelector('#result-slot-crafting img');
                if (!resultItem) { outputCode.textContent = "Erreur : Item de résultat manquant."; return {}; }
                const resultItemId = resultItem.getAttribute('data-item-id');
                
                let itemName = resultItemId.split(':').pop() || '';
                if (itemName.startsWith('minecraft_')) {
                    itemName = itemName.substring('minecraft_'.length);
                }

                const gridSlots = document.querySelectorAll('#crafting-grid .grid-slot');

                if (!Array.from(gridSlots).some(s => s.querySelector('img'))) {
                    outputCode.textContent = "Erreur : La grille de craft est vide."; return {};
                }

                if (currentCraftingType === 'shaped') {
                    return generateShapedRecipe(itemName, resultItemId, gridSlots);
                } else {
                    return generateShapelessRecipe(itemName, resultItemId, gridSlots);
                }
            }

            function generateShapedRecipe(itemName, resultItemId, gridSlots) {
                const recipe = { "format_version": "1.0.0", "minecraft:recipe_shaped": { description: { identifier: `minecraft:${itemName}` }, tags: ["crafting_table"], pattern: [], key: {}, result: { item: resultItemId, count: parseInt(resultCountInput.value, 10) || 1 } } };
                let gridData = Array.from(gridSlots).map(slot => slot.dataset.variants ? JSON.parse(slot.dataset.variants) : null);
                const charPool = '#*+S/|?@&%';
                let charIndex = 0;
                const uniqueItemGroups = new Map();

                gridData.forEach(itemGroup => {
                    if (itemGroup) {
                        const sortedGroup = JSON.stringify([...itemGroup].sort());
                        if (!uniqueItemGroups.has(sortedGroup)) {
                            uniqueItemGroups.set(sortedGroup, charPool[charIndex++ % charPool.length]);
                        }
                    }
                });

                uniqueItemGroups.forEach((char, groupJson) => {
                    const group = JSON.parse(groupJson);
                    recipe["minecraft:recipe_shaped"].key[char] = group.map(id => ({ "item": id }));
                });

                let minRow = 2, maxRow = 0, minCol = 2, maxCol = 0;
                let patternGrid = Array(3).fill(null).map(() => Array(3).fill(' '));
                
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        const itemGroup = gridData[i * 3 + j];
                        if (itemGroup) {
                            minRow = Math.min(minRow, i);
                            maxRow = Math.max(maxRow, i);
                            minCol = Math.min(minCol, j);
                            maxCol = Math.max(maxCol, j);
                            const sortedGroup = JSON.stringify([...itemGroup].sort());
                            patternGrid[i][j] = uniqueItemGroups.get(sortedGroup);
                        }
                    }
                }
                
                const finalPattern = [];
                for (let i = minRow; i <= maxRow; i++) {
                    finalPattern.push(patternGrid[i].slice(minCol, maxCol + 1).join(""));
                }
                recipe["minecraft:recipe_shaped"].pattern = finalPattern;
                
                const usedChars = new Set(finalPattern.join(''));
                for (const key in recipe["minecraft:recipe_shaped"].key) {
                    if (!usedChars.has(key) && key !== ' ') {
                        delete recipe["minecraft:recipe_shaped"].key[key];
                    }
                }
                return { recipe, fileName: `${itemName}.json` };
            }

            function generateShapelessRecipe(itemName, resultItemId, gridSlots) {
                const ingredients = [];
                gridSlots.forEach(slot => {
                    const itemImg = slot.querySelector('img');
                    if(itemImg) {
                        ingredients.push({ "item": itemImg.getAttribute('data-item-id') });
                    }
                });
                if (ingredients.length === 0) { outputCode.textContent = "Erreur : Aucun ingrédient."; return {}; }
                const recipe = { "format_version": "1.0.0", "minecraft:recipe_shapeless": { description: { identifier: `minecraft:${itemName}` }, tags: [ "crafting_table" ], ingredients: ingredients, result: { item: resultItemId, count: parseInt(resultCountInput.value, 10) || 1 } } };
                return { recipe, fileName: `${itemName}.json` };
            }

            function generateFurnaceRecipe() {
                const inputItem = document.querySelector('#input-slot-furnace img');
                const resultItem = document.querySelector('#result-slot-furnace img');
                if (!inputItem || !resultItem) { outputCode.textContent = "Erreur : Ingrédient et résultat requis."; return {}; }
                const inputItemId = inputItem.getAttribute('data-item-id');
                const resultItemId = resultItem.getAttribute('data-item-id');
                
                let resultItemName = resultItemId.split(':').pop() || '';
                if (resultItemName.startsWith('minecraft_')) {
                    resultItemName = resultItemName.substring('minecraft_'.length);
                }

                const experience = parseFloat(experienceInput.value) || 0;
                
                const recipe = { 
                    "format_version": "1.0.0", 
                    "minecraft:recipe_furnace": { 
                        description: { identifier: `minecraft:furnace_${resultItemName}` }, 
                        tags: [ "furnace", ...activeFurnaceTags ],
                        input: inputItemId,
                        output: resultItemId,
                        experience: experience
                    } 
                };

                return { recipe, fileName: `furnace_${resultItemName}.json` };
            }
                
            function showVariantModal(variants) {
                modalBody.innerHTML = '';
                variants.forEach(itemId => {
                    const itemData = items.get(itemId);
                    if (itemData) {
                        const itemEl = document.createElement('div');
                        itemEl.className = 'modal-item';
                        const img = document.createElement('img');
                        img.src = itemData.img;
                        const name = document.createTextNode(itemId.split(':')[1]);
                        itemEl.appendChild(img);
                        itemEl.appendChild(name);
                        modalBody.appendChild(itemEl);
                    }
                });
                variantModal.style.display = 'flex';
            }

            closeModalBtn.addEventListener('click', () => { variantModal.style.display = 'none'; });
            variantModal.addEventListener('click', (e) => {
                if (e.target === variantModal) {
                    variantModal.style.display = 'none';
                }
            });

            // --- Touch Drag and Drop Logic ---
            let touchDragGhost = null;
            let touchDragOriginalSlot = null;
            let currentTouchTarget = null;

            function handleTouchStart(e) {
                const target = e.target;
                const isItemInList = target.classList.contains('item');
                const slotElement = target.closest('.grid-slot');
                const isItemInSlot = slotElement && slotElement.querySelector('img');

                if (!isItemInList && !isItemInSlot) return;
                
                e.preventDefault();

                touchDragOriginalSlot = isItemInSlot ? slotElement : null;
                const originalImg = isItemInList ? target : slotElement.querySelector('img');

                touchDragGhost = originalImg.cloneNode(true);
                touchDragGhost.style.position = 'absolute';
                touchDragGhost.style.zIndex = '1000';
                touchDragGhost.style.pointerEvents = 'none';
                touchDragGhost.style.width = '60px';
                touchDragGhost.style.height = '60px';
                touchDragGhost.style.opacity = '0.7';
                document.body.appendChild(touchDragGhost);
                
                if (isItemInList) {
                    touchDragGhost.dataset.itemId = target.dataset.itemId;
                    touchDragGhost.dataset.source = 'list';
                } else {
                    touchDragGhost.dataset.variants = slotElement.dataset.variants || '[]';
                    touchDragGhost.dataset.source = 'slot';
                    originalImg.style.opacity = '0.4';
                }
                
                const touch = e.touches[0];
                moveGhost(touch.clientX, touch.clientY);

                document.addEventListener('touchmove', handleTouchMove, { passive: false });
                document.addEventListener('touchend', handleTouchEnd, { once: true });
            }

            function moveGhost(x, y) {
                if (!touchDragGhost) return;
                touchDragGhost.style.left = `${x - 30}px`;
                touchDragGhost.style.top = `${y - 30}px`;
            }

            function handleTouchMove(e) {
                if (!touchDragGhost) return;
                e.preventDefault();
                const touch = e.touches[0];
                moveGhost(touch.clientX, touch.clientY);

                touchDragGhost.style.display = 'none';
                const elementUnder = document.elementFromPoint(touch.clientX, touch.clientY);
                touchDragGhost.style.display = '';

                const newTarget = elementUnder ? elementUnder.closest('.grid-slot') : null;

                if (currentTouchTarget !== newTarget) {
                    if (currentTouchTarget) {
                        currentTouchTarget.classList.remove('drag-over');
                    }
                    if (newTarget) {
                        newTarget.classList.add('drag-over');
                    }
                    currentTouchTarget = newTarget;
                }
            }

            function handleTouchEnd(e) {
                document.removeEventListener('touchmove', handleTouchMove);
                if (!touchDragGhost) return;

                if (currentTouchTarget) {
                    const source = touchDragGhost.dataset.source;
                    if (source === 'list') {
                        handleItemDropFromList(currentTouchTarget, touchDragGhost.dataset.itemId);
                    } else if (source === 'slot') {
                        draggedSlotElement = touchDragOriginalSlot;
                        handleItemDropFromSlot(currentTouchTarget);
                    }
                }

                if (touchDragOriginalSlot) {
                    const originalImg = touchDragOriginalSlot.querySelector('img');
                    if (originalImg) originalImg.style.opacity = '1';
                }
                if (currentTouchTarget) {
                    currentTouchTarget.classList.remove('drag-over');
                }
                document.body.removeChild(touchDragGhost);

                touchDragGhost = null;
                touchDragOriginalSlot = null;
                currentTouchTarget = null;
                draggedSlotElement = null;
            }

            document.addEventListener('touchstart', handleTouchStart, { passive: false });
        });
    </script>
</body>
</html>